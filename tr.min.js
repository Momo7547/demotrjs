const trSymbol=Symbol(),ftSymbol=Symbol(),argRegExp=/\$\{\s*([^\}]*)\s*\}/,argPlaceholder="${}";function assemble(t,r){const e=Math.min(r.length,t.length-1),n=new Array(t.length+e);for(let s=0;s<e;++s)n[2*s]=t[s],n[2*s+1]=r[s];return n[n.length-1]=t[t.length-1],n.join("")}function addFormatter(t,r){t&&r&&("function"==typeof r.format?tr[ftSymbol].set(t,r.format.bind(r)):"function"==typeof r&&tr[ftSymbol].set(t,r))}class ArgDescriptor{constructor(t,r){this.position=parseInt(t),isNaN(this.position)&&(this.position=r),"#"===t&&(this.pluralValue=!0);const e=t.indexOf(":");e>=0&&(this.formatter=t.slice(e+1).trim())}getValue(t){const r=tr[ftSymbol].get(this.formatter),e=t[this.position];return r?r(e):e}}class Translator{constructor(t,r){if(this.sentence=this.parsePattern(t),"string"==typeof r)this.translation=this.parsePattern(r);else if(Array.isArray(r)){this.translations=new Array(r.length);for(let t=0;t<this.translations.length;++t)this.translations[t]=this.parsePattern(r[t])}else this.translation={strings:[String(r)],argDescriptions:[]}}static createPattern(t){return t.join("${}")}parsePattern(t){const r=t.split(argRegExp);return{strings:r.filter(((t,r)=>!(r%2))),argDescriptions:r.filter(((t,r)=>r%2)).map(((t,r)=>new ArgDescriptor(t,r)))}}get pattern(){return Translator.createPattern(this.sentence.strings)}get argumentIndexForPlural(){for(let t=0;t<this.sentence.argDescriptions.length;++t)if(this.sentence.argDescriptions[t].pluralValue)return t;return 0}getInfo(t){if(this.translations){const r=t[this.argumentIndexForPlural],e="number"==typeof r?r:r?1:0;return this.translations[Math.min(Math.max(0,e),this.translations.length-1)]}return this.translation}translate(t){const r=this.getInfo(t),e=new Array(r.argDescriptions.length);for(let n=0;n<e.length;++n)e[n]=r.argDescriptions[n].getValue(t);return assemble(r.strings,e)}}class SafeFormatter{constructor(t){this._formatter=t,"function"==typeof this._formatter.format&&(this._formatter=this._formatter.format.bind(this._formatter))}format(t){try{return this._formatter(t)}catch{return t}}}function tr(t,...r){if(Array.isArray(t)){const e=tr[trSymbol][Translator.createPattern(t)];return e?e.translate(r):assemble(t,r)}{"string"!=typeof t&&(t=String(t));const e=tr[trSymbol][t];return e?e.translate(r):assemble(t.split("${}"),r)}}tr.addTranslations=function(t){for(const r in t){const e=new Translator(r,t[r]);tr[trSymbol][e.pattern]=e}},tr.addFormatters=function(t){for(const r in t)addFormatter(r,new SafeFormatter(t[r]))},tr.load=function(t){for(const r in t.numberFormats)addFormatter(r,new SafeFormatter(new Intl.NumberFormat(t.locales,t.numberFormats[r])));for(const r in t.dateTimeFormats)addFormatter(r,new SafeFormatter(new Intl.DateTimeFormat(t.locales,t.dateTimeFormats[r])));tr.addTranslations(t.translations)},tr.clear=function(){tr[trSymbol]={},tr[ftSymbol]=new Map},tr.clear();export default tr;