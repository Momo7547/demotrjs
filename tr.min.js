const trSymbol=Symbol(),ftSymbol=Symbol(),argRegExp=/\$\{\s*([^\}]*)\s*\}/,argPlaceholder="${}";function assemble(t,r){const n=Math.min(r.length,t.length-1),e=new Array(t.length+n);for(let s=0;s<n;++s)e[2*s]=t[s],e[2*s+1]=r[s];return e[e.length-1]=t[t.length-1],e.join("")}function addFormatter(t,r){t&&r&&("function"==typeof r.format?tr[ftSymbol].set(t,r.format.bind(r)):"function"==typeof r&&tr[ftSymbol].set(t,r))}class ArgDescriptor{constructor(t,r){this.position=parseInt(t),isNaN(this.position)&&(this.position=r),"#"===t&&(this.pluralValue=!0);const n=t.indexOf(":");n>=0&&(this.formatter=t.slice(n+1).trim())}getValue(t){const r=tr[ftSymbol].get(this.formatter),n=t[this.position];return r?r(n):n}}class Translator{constructor(t,r){if(this.sentence=this.parsePattern(t),"string"==typeof r)this.translation=this.parsePattern(r);else if(Array.isArray(r)){this.translations=new Array(r.length);for(let t=0;t<this.translations.length;++t)this.translations[t]=this.parsePattern(r[t])}else this.translation={strings:[String(r)],argDescriptions:[]}}static createPattern(t){return t.join("${}")}parsePattern(t){const r=t.split(argRegExp);return{strings:r.filter(((t,r)=>!(r%2))),argDescriptions:r.filter(((t,r)=>r%2)).map(((t,r)=>new ArgDescriptor(t,r)))}}get pattern(){return Translator.createPattern(this.sentence.strings)}get argumentIndexForPlural(){for(let t=0;t<this.sentence.argDescriptions.length;++t)if(this.sentence.argDescriptions[t].pluralValue)return t;return 0}getInfo(t){if(this.translations){const r=t[this.argumentIndexForPlural],n="number"==typeof r?r:r?1:0;return this.translations[Math.min(Math.max(0,n),this.translations.length-1)]}return this.translation}translate(t){const r=this.getInfo(t),n=new Array(r.argDescriptions.length);for(let e=0;e<n.length;++e)n[e]=r.argDescriptions[e].getValue(t);return assemble(r.strings,n)}}function tr(t,...r){if(Array.isArray(t)){const n=tr[trSymbol][Translator.createPattern(t)];return n?n.translate(r):assemble(t,r)}{"string"!=typeof t&&(t=String(t));const n=tr[trSymbol][t];return n?n.translate(r):assemble(t.split("${}"),r)}}tr.addTranslations=function(t){for(const r in t){const n=new Translator(r,t[r]);tr[trSymbol][n.pattern]=n}},tr.addFormatters=function(t){for(const r in t)addFormatter(r,t[r])},tr.load=function(t){for(const r in t.numberFormats)addFormatter(r,new Intl.NumberFormat(t.locales,t.numberFormats[r]));for(const r in t.dateTimeFormats)addFormatter(r,new Intl.DateTimeFormat(t.locales,t.dateTimeFormats[r]));tr.addTranslations(t.translations)},tr.clear=function(){tr[trSymbol]={},tr[ftSymbol]=new Map},tr.clear();export default tr;